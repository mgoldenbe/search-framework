#ifndef SLB_EXTENSIONS_ALGORITHMS_PER_GOAL_H
#define SLB_EXTENSIONS_ALGORITHMS_PER_GOAL_H

/// \file
/// \brief The \ref slb::ext::algorithm::PerGoal class.
/// \author Meir Goldenberg

#include "algorithm.h"

namespace slb {
namespace ext {
namespace algorithm {

/// \c PerGoal is a meta search algorithm for solving instances with multiple
/// goals. It runs some other search algorithm for each goal state and combines
/// results. Each goal state is solved independently of all others.
/// \tparam logFlag If \c true, the events generated by the search algorithm are
/// logged. Otherwise, they are not.
/// \tparam Node_ The search node type.
/// \tparam BaseAlgorithm The search algorithm to run for each goal state.
template <bool logFlag, class Node_ = SLB_NODE,
          class BaseAlgorithm = SLB_PER_GOAL_BASE_ALGORITHM<logFlag>>
struct PerGoal {
    /// The search node type.
    using Node = Node_;

    /// The state type. Identifies the domain.
    using State = typename Node::State;

    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// The action cost type.
    using CostType = typename State::CostType;

    /// The type of the value returned by the algorithm (see the \ref run member function).
    using ReturnType = double;

    /// The type for the log of events generated by the algorithm.
    using MyAlgorithmLog =
        typename std::conditional<logFlag, AlgorithmLog<Node>, Nothing>::type;

    /// Initializes the algorithm based on the problem instance.
    /// \param instance The problem instance.
    PerGoal(const MyInstance &instance) : instance_(instance) {}

    /// Runs the algorithm.
    /// \return The solution cost, which is the average of solution costs among
    /// the goals.
    /// \warning There is no special treatment for instances that do not have a
    /// solution at this point.
    ReturnType run() {
        ReturnType res = 0.0;
        for (auto i : instance_.goalInstances()) {
            BaseAlgorithm alg(i);
            res += alg.run();
            stats_.append(alg.measures());

            // Collect expanded sets.
            // TODO: do this only when alg.oc is available.
            for (const auto &el: alg.oc().hash())
                if (el.second->bucketPosition() < 0) // closed node
                    ++expanded[el.first];
        }
        return res / instance_.goalInstances().size();
    }

    /// Returns the statistics about the underlying search algorithm's
    /// performance for solving the particular instance for all goal states.
    /// \return The statistics about the underlying search algorithm's
    /// performance for solving the particular instance for all goal states.
    MeasureSet measures() const {
        MeasureSet res = stats_.sum(true)[0];
        Measure expPerState("Exp. per state");
        double sum = 0;
        for (const auto &el: expanded)
            sum += el.second;
        expPerState.set(sum / expanded.size());
        res.append(expPerState);
        return res;
    }

    /// Returns the log of events generated by the search algorithm.
    /// \return Const reference to the log of events generated by the search
    /// algorithm.
    MyAlgorithmLog &log() { return log_; }

private:
    /// The instance.
    MyInstance instance_;

    /// The log of events generated by the search algorithm.
    MyAlgorithmLog log_;

    /// Statistics about the underlying search algorithm's performance for
    /// solving for all goal states.
    Stats stats_;

    /// Mapping of each expanded state to the number of goals for which it was expanded.
    std::unordered_map<State, int, core::util::StateHash<State>> expanded;
};

} // namespace
} // namespace
} // namespace

#endif
