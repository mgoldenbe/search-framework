#ifndef SLB_EXTENSIONS_ALGORITHMS_PER_GOAL_H
#define SLB_EXTENSIONS_ALGORITHMS_PER_GOAL_H

/// \file
/// \brief The \ref slb::ext::algorithm::PerGoal class.
/// \author Meir Goldenberg

#include "algorithm.h"

namespace slb {
namespace ext {
namespace algorithm {
namespace pergoal {

/// Additions to the command line related to the PerGoal algorithm.
struct CommandLine {
    /// Returns whether the goal being expanded by a prefious search is checked.
    /// \return true if the goal being expanded by a prefious search is checked and false otherwise.
    bool checkGoalExpanded() { return checkGoalExpanded_.isSet(); }

    /// Returns whether the search algorithm should be supplied a secondary closed list.
    /// \return true if the search algorithm should be supplied a secondary closed list and false otherwise.
    bool secondaryCL() { return secondaryCL_.isSet(); }

private:
    /// Command line option for checking the goal in previous searches.
    TCLAP::SwitchArg checkGoalExpanded_;

    /// Command line option for secondary closed list.
    TCLAP::SwitchArg secondaryCL_;

protected:
    /// Injects this addition to the command line object.
    /// \param cmd The command-line object.
    CommandLine(TCLAP::CmdLine &cmd)
        : checkGoalExpanded_("", "checkGoalExpanded",
                             "Check the goal in previous searches.", cmd,
                             false),
          secondaryCL_("", "secondaryCL", "Supply secondary closed list.", cmd,
                       false) {}
};

/// \c PerGoal is a meta search algorithm for solving instances with multiple
/// goals. It runs some other search algorithm for each goal state and combines
/// results. Each goal state is solved independently of all others.
/// \tparam logFlag If \c true, the events generated by the search algorithm are
/// logged. Otherwise, they are not.
/// \tparam Node_ The search node type.
/// \tparam BaseAlgorithm The search algorithm to run for each goal state.
template <bool logFlag, class Node_ = SLB_NODE,
          class BaseAlgorithm = SLB_PER_GOAL_BASE_ALGORITHM<logFlag>>
struct PerGoal {
    /// The search node type.
    using Node = Node_;

    /// The state type. Identifies the domain.
    using State = typename Node::State;

    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// The action cost type.
    using CostType = typename State::CostType;

    /// The type of the value returned by the algorithm (see the \ref run member function).
    using ReturnType = double;

    /// The type for the log of events generated by the algorithm.
    using MyAlgorithmLog =
        typename std::conditional<logFlag, AlgorithmLog<Node>, Nothing>::type;

    /// Initializes the algorithm based on the problem instance.
    /// \param instance The problem instance.
    PerGoal(const MyInstance &instance) : instance_(instance) {}

    /// Runs the algorithm.
    /// \return The solution cost, which is the average of solution costs among
    /// the goals.
    /// \warning There is no special treatment for instances that do not have a
    /// solution at this point.
    template <CMD_TPARAM> ReturnType run() {
        ReturnType res = 0.0;
        core::sb::SecondaryCL<Node> distanceMap;
        BaseAlgorithm **algs =
            new BaseAlgorithm *[instance_.goalInstances().size()];
        int index = 0;
        for (auto i : instance_.goalInstances()) {
            BaseAlgorithm *algp = new BaseAlgorithm(i);
            BaseAlgorithm &alg = *algp;
            algs[index] = algp;
            if (CMD_T.secondaryCL()) alg.setSecondaryCL(distanceMap);

            auto it = distanceMap.find(&i.goal());
            if (CMD_T.checkGoalExpanded() && it != distanceMap.end()) {
                alg.setCost(it->second->g);
                res += it->second->g;
            }
            else
                res += alg.run();
            stats_.append(alg.measures());

            // Collect expanded sets.
            // TODO: do this only when alg.oc is available.
            for (const auto &state : alg.expanded(true)) ++expanded[state];
            alg.updateSecondaryCL();

            if (!CMD_T.secondaryCL()) {
                delete algs[index];
                algs[index] = nullptr;
            }
            index++;
        }
        for (int i = 0; i < index; ++i) delete algs[i];
        delete[] algs;
        return res / instance_.goalInstances().size();
    }

    /// Returns the statistics about the underlying search algorithm's
    /// performance for solving the particular instance for all goal states.
    /// \return The statistics about the underlying search algorithm's
    /// performance for solving the particular instance for all goal states.
    MeasureSet measures() const {
        MeasureSet res = stats_.sum(true)[0];
        Measure expPerState("Exp. per state");
        double sum = 0;
        for (const auto &el: expanded)
            sum += el.second;
        expPerState.set(sum / expanded.size());
        res.append(expPerState);
        return res;
    }

    /// Returns the log of events generated by the search algorithm.
    /// \return Const reference to the log of events generated by the search
    /// algorithm.
    MyAlgorithmLog &log() { return log_; }

private:
    /// The instance.
    MyInstance instance_;

    /// The log of events generated by the search algorithm.
    MyAlgorithmLog log_;

    /// Statistics about the underlying search algorithm's performance for
    /// solving for all goal states.
    Stats stats_;

    /// Mapping of each expanded state to the number of goals for which it was expanded.
    std::unordered_map<State, int, core::util::StateHash<State>> expanded;
};

} // namespace
} // namespace
} // namespace
} // namespace

#endif
